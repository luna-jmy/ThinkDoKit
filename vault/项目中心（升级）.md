---
cssclasses:
  - fullwidth
  - matrix
start_date: 2025-01-01
due_date: 2025-12-31
obsidianUIMode: preview
---

| `button-projectFolder` | `button-mainProject` |
| ---------------------- | -------------------- |
## é¡¹ç›®ä¸€è§ˆ
>*æœ‰ä¸»é¡¹ç›®æ–‡ä»¶çš„é»˜è®¤æ˜¾ç¤ºä¸»é¡¹ç›®æ–‡ä»¶åã€‚æ— ä¸»é¡¹ç›®æ–‡ä»¶çš„æ˜¾ç¤ºæ–‡ä»¶å¤¹åã€‚æœ€å¤šé¢„è§ˆ5ä¸ªé¡¹ç›®ç¬”è®°ï¼Œå¯åœ¨ä»£ç çš„ç¬¬ä¸€è¡Œå‚æ•° `maxNotesDisplay = 5` é‡Œä¿®æ”¹é¢„è§ˆç¬”è®°æ•°é‡ã€‚*

```dataviewjs
const maxNotesDisplay = 5;

const currentPage = dv.current();
const filterStart = currentPage.start_date;
const filterEnd = currentPage.due_date;

const allNotes = dv.pages('"100 Projects"')
    .where(p => p.file.folder !== "100 Projects");

const rootFolder = app.vault.getAbstractFileByPath("100 Projects");
const physicalFolders = rootFolder && rootFolder.children 
    ? rootFolder.children.filter(f => f.children)
    : [];

const projectMap = new Map();
physicalFolders.forEach(f => projectMap.set(f.path, []));

allNotes.forEach(page => {
    for (const folderPath of projectMap.keys()) {
        if (page.file.folder === folderPath || page.file.folder.startsWith(folderPath + "/")) {
            projectMap.get(folderPath).push(page);
            break;
        }
    }
});

const projectGroups = Array.from(projectMap.entries())
    .map(([path, notes]) => {
        const projectFile = notes.find(n => n.type === "project");
        let sortDate = null;
        if (projectFile) {
            sortDate = projectFile.due_date || projectFile.end_date;
        }
        return { key: path, rows: notes, sortDate: sortDate };
    })
    .sort((a, b) => {
        // å¦‚æœä¸¤ä¸ªéƒ½æœ‰æ—¥æœŸï¼ŒæŒ‰æ—¥æœŸé™åºï¼ˆæ–°åˆ°æ—§ï¼‰
        if (a.sortDate && b.sortDate) {
            if (a.sortDate > b.sortDate) return -1;
            if (a.sortDate < b.sortDate) return 1;
        }
        // å¦‚æœåªæœ‰ä¸€ä¸ªæœ‰æ—¥æœŸï¼Œæœ‰æ—¥æœŸçš„æ’å‰é¢
        if (a.sortDate && !b.sortDate) return -1;
        if (!a.sortDate && b.sortDate) return 1;
        
        // å¦‚æœéƒ½æ²¡æœ‰æ—¥æœŸï¼Œæˆ–æ—¥æœŸç›¸åŒï¼ŒæŒ‰æ–‡ä»¶å¤¹åç§°æ’åº
        return a.key.localeCompare(b.key);
    });

const container = dv.container.createEl("div", { cls: "projects-container" });

let displayedProjects = 0;

for (let group of projectGroups) {
    const folderPath = group.key;
    const folderName = folderPath.split("/").pop();
    const notes = group.rows;

    const projectFile = notes.find(n => n.type === "project");

    let projectName, startDate, endDate, status, priority, progress;

    if (projectFile) {
        projectName = projectFile.file.name;
        startDate = projectFile.start_date || "";
        endDate = projectFile.due_date || projectFile.end_date || "";
        status = projectFile.status || "";
        priority = projectFile.priority || "";
        progress = projectFile.progress || "";
    } else {
        const dateMatch = folderName.match(/^(\d{6})(.*)$/);
        projectName = dateMatch ? dateMatch[2].trim() : folderName; 
        
        startDate = dateMatch ? `${dateMatch[1].substring(0,4)}-${dateMatch[1].substring(4,6)}-01` : "";
        endDate = "";
        status = "";
        priority = "";
        progress = "";
    }

    let shouldDisplay = false;

    if (!projectFile) {
        shouldDisplay = true;
    } else if (startDate && endDate) {
        shouldDisplay = (startDate <= filterEnd && endDate >= filterStart);
    } else if (startDate) {
        shouldDisplay = (startDate >= filterStart && startDate <= filterEnd);
    } else if (endDate) {
        shouldDisplay = (endDate >= filterStart && endDate <= filterEnd);
    } else {
        shouldDisplay = true;
    }

    if (shouldDisplay) {
        displayedProjects++;

        const card = container.createEl("div", { cls: "project-card" });

        const titleWrapper = card.createEl("div", {
            attr: { style: "display: flex; justify-content: space-between; align-items: start;" }
        });

        const title = titleWrapper.createEl("h3", {
            attr: { style: "margin: 0; flex: 1;" }
        });
        
        if (projectFile) {
            const link = title.createEl("a", {
                cls: "internal-link",
                href: projectFile.file.path,
                attr: { "data-href": projectFile.file.path } 
            });
            link.textContent = projectName;
            link.style.color = "inherit";
            link.style.textDecoration = "none";
        } else {
            title.textContent = projectName;
        }

        const badgesWrapper = titleWrapper.createEl("div", {
            attr: { style: "display: flex; gap: 5px; margin-top: 5px;" }
        });

        if (!projectFile) {
            const missingBadge = badgesWrapper.createEl("span", {
                cls: "project-status",
                attr: { style: "margin: 0; background: rgba(255, 100, 100, 0.2); color: var(--text-normal);" }
            });
            missingBadge.textContent = "âš ï¸ æ— ä¸»æ–‡ä»¶";
        }

        if (priority) {
            const priorityBadge = badgesWrapper.createEl("span", {
                cls: "project-status",
                attr: { style: "margin: 0;" }
            });
            const priorityMap = {
                "1": "ğŸ”´", "2": "ğŸŸ ", "3": "ğŸŸ¡", "4": "ğŸ”µ", "5": "âšª",
                "æœ€é«˜": "ğŸ”´", "é«˜": "ğŸŸ ", "ä¸­": "ğŸŸ¡", "ä½": "ğŸ”µ", "æœ€ä½": "âšª"
            };
            priorityBadge.textContent = priorityMap[priority] || priority;
        }

        if (status) {
            const statusBadge = badgesWrapper.createEl("span", {
                cls: "project-status",
                attr: { style: "margin: 0;" }
            });
            const statusMap = {
                "inbox": "ğŸ“¥", "draft": "âœï¸", "active": "ğŸš€",
                "on-hold": "â¸ï¸", "completed": "âœ…", "cancelled": "âŒ", "archived": "ğŸ“¦",
                "æœªå¼€å§‹/å¾…å¯åŠ¨": "ğŸ“¥", "èµ·è‰/æ„æ€ä¸­": "âœï¸", "æ‰§è¡Œä¸­": "ğŸš€",
                "æš‚åœ": "â¸ï¸", "å®Œæˆ": "âœ…", "å–æ¶ˆ": "âŒ", "å½’æ¡£": "ğŸ“¦"
            };
            statusBadge.textContent = statusMap[status] || status;

            if (status === "active" || status === "æ‰§è¡Œä¸­") {
                statusBadge.classList.add("active");
            } else if (status === "completed" || status === "å®Œæˆ") {
                statusBadge.classList.add("completed");
            } else if (status === "inbox" || status === "draft" || status === "æœªå¼€å§‹/å¾…å¯åŠ¨" || status === "èµ·è‰/æ„æ€ä¸­") {
                statusBadge.classList.add("planned");
            }
        }

        if (progress) {
            const progressBar = card.createEl("div", {
                attr: {
                    style: "width: 100%; height: 8px; background: var(--background-modifier-border); border-radius: 4px; margin: 10px 0; overflow: hidden;"
                }
            });
            const progressFill = progressBar.createEl("div", {
                attr: {
                    style: `width: ${progress}%; height: 100%; background: var(--interactive-accent); transition: width 0.3s ease;`
                }
            });
        }

        const notesDiv = card.createEl("div", { cls: "project-notes" });

        const notesList = notes.filter(n => n.type !== "project");

        if (notesList.length > 0) {
            const ul = notesDiv.createEl("ul");

            const notesToShow = maxNotesDisplay === 0 ? notesList : notesList.slice(0, maxNotesDisplay);

            notesToShow.forEach(note => {
                const li = ul.createEl("li");
                const link = li.createEl("a", {
                    cls: "internal-link",
                    href: note.file.path
                });
                link.textContent = note.file.name;
            });

            if (maxNotesDisplay > 0 && notesList.length > maxNotesDisplay) {
                const moreText = notesDiv.createEl("div", {
                    cls: "notes-empty"
                });
                moreText.textContent = `è¿˜æœ‰ ${notesList.length - maxNotesDisplay} ä¸ªç¬”è®°...`;
            }
        } else {
            const emptyText = notesDiv.createEl("div", { cls: "notes-empty" });
            emptyText.textContent = "æš‚æ— ç¬”è®°";
        }

        const meta = card.createEl("div", { cls: "project-meta" });

        const dateDiv = meta.createEl("div", { cls: "project-date" });
        const startDateFormatted = startDate ? dv.date(startDate).toFormat("yyyy-MM-dd") : "";
        const endDateFormatted = endDate ? dv.date(endDate).toFormat("yyyy-MM-dd") : "";
        const dateText = endDateFormatted
            ? `ğŸ“… ${startDateFormatted} ~ ${endDateFormatted}`
            : startDateFormatted
                ? `ğŸ“… ${startDateFormatted}`
                : "ğŸ“… æ—¥æœŸæœªè®¾ç½®";
        dateDiv.textContent = dateText;

        const countDiv = meta.createEl("div", { cls: "project-count" });
        countDiv.textContent = `ğŸ“ ${notesList.length} ä¸ªç¬”è®°`;
    }
}

if (displayedProjects === 0) {
    const empty = container.createEl("div", { cls: "project-empty" });
    empty.textContent = "ğŸ“­ å½“å‰æ—¶é—´æ®µå†…æ²¡æœ‰é¡¹ç›®";
}

const filterStartFormatted = dv.date(filterStart).toFormat("yyyy-MM-dd");
const filterEndFormatted = dv.date(filterEnd).toFormat("yyyy-MM-dd");
const filterInfo = dv.el("p", `ğŸ“Š æ˜¾ç¤º ${displayedProjects} ä¸ªé¡¹ç›® (${filterStartFormatted} ~ ${filterEndFormatted})`, {
    attr: { style: "color: var(--text-muted); margin-bottom: 10px;" }
});
```

## é¡¹ç›®è¿›åº¦

```dataviewjs
const currentPage = dv.current();
const filterStart = currentPage.start_date;
const filterEnd = currentPage.due_date;

const pages = dv.pages('#project')
    .where(p => p.type === "project")
    .where(p => p.start_date && p.due_date)
    .where(p => {
        const projectStart = dv.date(p.start_date);
        const projectEnd = dv.date(p.due_date);
        const filterStartDate = dv.date(filterStart);
        const filterEndDate = dv.date(filterEnd);
        return projectStart <= filterEndDate && projectEnd >= filterStartDate;
    })
    .where(p => p.status !== "cancelled")
    .sort(p => p.due_date, 'asc');

let mermaidCode = "```mermaid\ngantt\n";
mermaidCode += "    title é¡¹ç›®è¿›åº¦ç”˜ç‰¹å›¾\n";
mermaidCode += "    dateFormat YYYY-MM-DD\n";
mermaidCode += "    axisFormat %y-%m\n\n";

const groupedPages = {};
pages.forEach(page => {
    const objective = page.objective || "é»˜è®¤é¡¹ç›®";
    if (!groupedPages[objective]) {
        groupedPages[objective] = [];
    }
    groupedPages[objective].push(page);
});

Object.keys(groupedPages).forEach(context => {
    if (Object.keys(groupedPages).length > 1) {
        mermaidCode += `    section ${context}\n`;
    }

    groupedPages[context].forEach(page => {
        const taskName = page.file.name.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, ''); 
        const startDate = dv.date(page.start_date).toFormat("yyyy-MM-dd");
        const dueDate = dv.date(page.due_date).toFormat("yyyy-MM-dd");

        let status = "";
        if (page.status === "completed") {
            status = "done, ";
        } else if (page.status === "active") {
            status = "active, ";
        }

        mermaidCode += `    ${page.file.name} :${status}${taskName}, ${startDate}, ${dueDate}\n`;
    });

    mermaidCode += "\n";
});

mermaidCode += "```";

dv.paragraph(mermaidCode);
```

## å¿«é€Ÿä¿®æ”¹é¡¹ç›®ä¿¡æ¯
![[é¡¹ç›®ç®¡ç†.base]]
